import random
import copy
import matplotlib.pyplot as plt
from tkinter import *


'''
CS 461 Homework 2

Team: 
Merve Nur AKYER
Cihan ERKAN
Osman Burak INTISAH
Burak Can BINER

We used h1: number of misplaced tiles as our heuristic.

Algorithm to follow:

Output: 

'''
def print_state(state):
    '''
    Prints the current state
    '''
    print("----------")
    for row in state:
        print(row)
    print("----------")

def move(state, x, y, dir):
    '''
    This function checks whether or not the move that is done on the puzzle is correct or not
    :param state: current state of the puzzle
    :param x: the x coordinate of the -1
    :param y: the y coordinate of the -1
    :param dir: the direction where -1 goes
    :return: wheter or not the move is correct or wrong
            if the return value is 1 the move is viable
            if he return value is -1 the move is not viable
    '''
    if (x < 0) or (y < 0) or (x > 2) or (y > 2):
        return -1

    if dir == "up":
        if state[y - 1][x] == -1:
            state[y - 1][x] = state[y][x]
            state[y][x] = -1
            st = str(state[y - 1][x] ) + "down"
            return 1, st
        else:
            print("Wrong move")
            return -1
    elif dir == "down":
        if state[y + 1][x] == -1:
            state[y + 1][x] = state[y][x]
            state[y][x] = -1
            st = str(state[y + 1][x]) + "up"
            return 1,st
        else:
            print("Wrong move")
            return -1
    elif dir == "left":
        if state[y][x - 1] == -1:
            state[y][x - 1] = state[y][x]
            state[y][x] = -1
            st = str(state[y][x-1]) + "right"
            return 1
        else:
            print("Wrong move")
            return -1
    elif dir == "right":
        if state[y][x + 1] == -1:
            state[y][x + 1] = state[y][x]
            state[y][x] = -1
            st = str(state[y][x]) + "left"
            return 1
        else:
            print("Wrong move")
            return -1


def possible_states(state):
    '''
    This function calculates the states and adds it to a list which can be achieved from the given state


    :param state: current state which is on the puzzle
    :return: states that can be achieved from the given state
    '''
    loc_x = 0
    loc_y = 0
    for y in range(3):
        for x in range(3):
            if state[y][x] == -1:
                loc_x = x
                loc_y = y
    x = loc_x
    y = loc_y

    new_states = []

    up_state = copy.deepcopy(state)
    down_state = copy.deepcopy(state)
    left_state = copy.deepcopy(state)
    right_state = copy.deepcopy(state)

    if move(up_state, x, y + 1, "up") != -1:
        new_states.append(up_state)

    if move(down_state, x, y - 1, "down") != -1:
        new_states.append(down_state)

    if move(left_state, x + 1, y, "left") != -1:
        new_states.append(left_state)

    if move(right_state, x - 1, y, "right") != -1:
        new_states.append(right_state)
    return new_states

def generate_state():
    '''
    This function generates the initial states that are solvable
    :return: state which is going to be solved with the A* search algorithm
    '''
    state = [[1, 2, 3], [4, 5, 6], [7, 8, -1]]
    iter = 15

    for i in range(iter):
        new_states = possible_states(state)
        index = random.randint(0, len(new_states) - 1)
        state = new_states[index]
    return state

def h1(state):
    '''
    This function calculates h1:number of misplaced tiles for a given state

    :param state: given state
    return: number of misplaced tiles of the given state
    '''
    init_state = [[1, 2, 3], [4, 5, 6], [7, 8, -1]]
    count = 0

    for y in range(3):
        for x in range(3):
            if init_state[y][x] != state[y][x]:
                count += 1

    return count

def h1_helper(list):
    '''
    This function calculates h1 value for the final state of a path, this functions is used for sorting paths for the A* algorithm

    :param list: given list
    return: number of misplaced tiles of the final state of the given path
    '''
    last_state_of_path = list[len(list)-1]
    return h1(last_state_of_path)



def searchStats(state):
    '''
    This is A* search algorithm which is given in the book chapter 5

    :param state: this is the initial state which is the initial state of the puzzle generated by generateState
    :return: the states that has seen while finding the result state
    '''
    queue = []
    path = []
    path.append(state)
    queue.append(path)
    while True:
        #print(len(queue))
        if len(queue) != 0:
            pth = queue.pop(0)
            last_state = pth[len(pth) - 1]
            nxt_states = possible_states(last_state)
            new_paths = []

            for st in nxt_states:

                if st == [[1, 2, 3], [4, 5, 6], [7, 8, -1]]:
                    print("The solution is found.")
                    new_path = pth
                    new_path.append(st)

                    return new_path
                if st not in pth:
                    # Searches whether or not that state is occurred before.
                    # If not adding it to the new paths list.
                    new_path = copy.deepcopy(pth)
                    new_path.append(st)
                    new_paths.append(new_path)

            '''With the following part we check detect two or more paths reach a common not or not.
            If we find such paths we delete the paths with the more cost.'''

            for pt in new_paths:
                last_state = pt[len(pt) - 1]
                not_found = True
                not_found2 = True
                for q in queue:
                    if  not_found :
                        for state in q:
                            if not_found2:
                                if last_state == state:
                                    if q.index(state) > len(pt):
                                        queue.remove(q)
                                    else:
                                        new_paths.remove(pt)
                                        not_found = False
                                        not_found2 = False

            for pt in new_paths:
                queue.append(pt)

            '''
            With the 'sorted' method we sort the paths in the queue with respect to their final state's h1 value.
            '''
            sorted(queue, key=h1_helper)

        else:
            print("The solution could not found for the initial state.")
            return

"""
First We are generating 30 different initial states of the puzzle 
After generating, it is displayed as textual representation 
"""

initial_states = []
count = 0
while count < 30:
    new = generate_state()
    if new not in initial_states:
        count += 1
        print("Inittial State: " + str(count))
        initial_states.append(new)
        print_state(new)

no_of_moves = []

'''
Number of moves added to an array which will be used to draw the plot
As it is stated in the homework description We did not use loop (avoided loops).
each solution_  will include the solution paths that has been achieved for each initial state
'''

solutions = []

for i in range (0,30):
    solutions.append(searchStats(initial_states[i]))
    no_of_moves.append(len(solutions[i]))

# Initialize the plot
fig = plt.figure(figsize=(10,10))
graph = fig.add_subplot(111)

x_axis = []
for i in range (1,31):
    x_axis.append(i)

# Plot the data
graph.bar( x_axis , no_of_moves)
graph.set_title('Number of Moves to Reach Goal State')
graph.set_xlabel('Initial-state Numbers')
graph.set_ylabel('Tile Moves')
# Show the plot
plt.show()

master = Tk()
master.title("ArcticFoxes")
w = Canvas(master, width=1500, height=1000, bg="white")

offset_x = 15
offset_y = 50
size = 50
table_nu = 0


''' 
Following part traces two of 30 solutions. Each step demonstrated with the help of GUI.
'''
w.create_text(offset_x+150, offset_y-25 , font="Times 20", text="Trace for state no. 12:" , fill="red")
show1 = solutions[12]
for table in show1:
    for i in range(3):
        for j in range(3):
            x = 300* table_nu + 50 * i + offset_x
            y = 50 * j + offset_y

            num = table[j][i]
            if num == -1:
                w.create_rectangle(x, y, x + size, y + size, outline="black", width=3,fill="gray")
            else:
                w.create_rectangle(x, y, x + size, y + size, outline="black", width=3)
                w.create_text(x + 25, y + 25, font="Times 20 bold", text=str(num) , fill="blue")

    table_nu = table_nu + 1
    if show1.index(table) == 0:
        w.create_text(x-10,y+100,font="Times 20", text="Initial", fill="red")
    elif show1.index(table) == len(show1)-1:
        w.create_text(x - 10, y + 100, font="Times 20", text="Goal", fill="red")

    if show1.index(table) != 0:
        w.create_line(x-215, y-25, x-125, y-25, fill='blue', arrow='last', width=4)
        before = show1[show1.index(table)-1]
        for i in range (0,3):
            for j in range (0,3):
                if before[i][j] != table [i][j] and before[i][j] != -1:
                    if i>0 and before[i-1][j] == -1:
                        w.create_text(x - 175, y - 50, font="Times 20",text=str(before[i][j])+" up")
                    elif i<2 and before[i+1][j] == -1:
                        w.create_text(x - 175, y - 50, font="Times 20",text=str(before[i][j])+" down")
                    elif j>0 and before[i][j-1] == -1:
                        w.create_text(x - 175, y - 50, font="Times 20",text=str(before[i][j])+" left")
                    elif j<2 and before[i][j+1] == -1:
                        w.create_text(x - 175, y - 50, font="Times 20",text=str(before[i][j])+" right")



table_nu = 0
w.create_text(offset_x+150, offset_y + 475 , font="Times 20", text="Trace for state no. 22:" , fill="red")
show2 = solutions[22]
for table in show2:

    for i in range(3):
        for j in range(3):
            x = 300* table_nu + 50 * i + offset_x
            y = 50 * j + offset_y + 500

            num = table[j][i]
            if num == -1:
                w.create_rectangle(x, y, x + size, y + size, outline="black", width=3, fill="gray")
            else:
                w.create_rectangle(x, y, x + size, y + size, outline="black", width=3)
                w.create_text(x + 25, y + 25, font="Times 20 bold", text=str(num) , fill="blue")
    table_nu = table_nu + 1
    if show2.index(table) == 0:
        w.create_text(x-10,y+100,font="Times 20", text="Initial" , fill="red")
    if show2.index(table) == len(show2)-1:
            w.create_text(x - 10, y + 100, font="Times 20", text="Goal", fill="red")
    if show2.index(table) != 0:
        w.create_line(x - 215, y - 25, x - 125, y - 25, fill='blue', arrow='last', width=4)
        before = show2[show2.index(table) - 1]
        for i in range(0, 3):
            for j in range(0, 3):
                if before[i][j] != table[i][j] and before[i][j] != -1:
                    if i > 0 and before[i - 1][j] == -1:
                        w.create_text(x - 175, y - 50, font="Times 20", text=str(before[i][j]) + " up")
                    elif i < 2 and before[i + 1][j] == -1:
                        w.create_text(x - 175, y - 50, font="Times 20", text=str(before[i][j]) + " down")
                    elif j > 0 and before[i][j - 1] == -1:
                        w.create_text(x - 175, y - 50 , font="Times 20", text=str(before[i][j]) + " left")
                    elif j < 2 and before[i][j + 1] == -1:
                        w.create_text(x - 175, y - 50, font="Times 20", text=str(before[i][j]) + " right")

'''
A horizontal scrollbar is added since we may have solutions with high number of steps.
'''
scrollbar = Scrollbar(master,orient='horizontal')
scrollbar.config(command=w.xview)
scrollbar.pack(side=BOTTOM, fill=X)

w.pack()
master.mainloop()
