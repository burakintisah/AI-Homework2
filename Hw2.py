import random
import copy
import matplotlib.pyplot as plt
from tkinter import *

def print_state(state):
    '''
    Prints the current state
    '''
    print("----------")
    for row in state:
        print(row)
    print("----------")

def move(state, x, y, dir):
    '''
    This function checks whether or not the move that is done on the puzzle is correct or not
    :param state: current state of the puzzle
    :param x: the x coordinate of the -1
    :param y: the y coordinate of the -1
    :param dir: the direction where -1 goes
    :return: wheter or not the move is correct or wrong
            if the return value is 1 the move is viable
            if he return value is -1 the move is not viable
    '''
    if (x < 0) or (y < 0) or (x > 2) or (y > 2):
        return -1

    if dir == "up":
        if state[y - 1][x] == -1:
            state[y - 1][x] = state[y][x]
            state[y][x] = -1
            return 1
        else:
            print("Wrong move")
            return -1
    elif dir == "down":
        if state[y + 1][x] == -1:
            state[y + 1][x] = state[y][x]
            state[y][x] = -1
            return 1
        else:
            print("Wrong move")
            return -1
    elif dir == "left":
        if state[y][x - 1] == -1:
            state[y][x - 1] = state[y][x]
            state[y][x] = -1
            return 1
        else:
            print("Wrong move")
            return -1
    elif dir == "right":
        if state[y][x + 1] == -1:
            state[y][x + 1] = state[y][x]
            state[y][x] = -1
            return 1
        else:
            print("Wrong move")
            return -1


def possible_states(state):
    '''
    This function calculates the states and adds it to a list which can be achieved from the given state


    :param state: current state which is on the puzzle
    :return: states that can be achieved from the given state
    '''
    loc_x = 0
    loc_y = 0
    for y in range(3):
        for x in range(3):
            if state[y][x] == -1:
                loc_x = x
                loc_y = y
    x = loc_x
    y = loc_y

    new_states = []

    up_state = copy.deepcopy(state)
    down_state = copy.deepcopy(state)
    left_state = copy.deepcopy(state)
    right_state = copy.deepcopy(state)

    if move(up_state, x, y + 1, "up") != -1:
        new_states.append(up_state)

    if move(down_state, x, y - 1, "down") != -1:
        new_states.append(down_state)

    if move(left_state, x + 1, y, "left") != -1:
        new_states.append(left_state)

    if move(right_state, x - 1, y, "right") != -1:
        new_states.append(right_state)
    return new_states

def generate_state():
    '''
    This function generates the initial states that are solveable
    :return: state which is going to be solved with the A* search algorithm
    '''
    state = [[1, 2, 3], [4, 5, 6], [7, 8, -1]]
    iter = 10

    for i in range(iter):
        new_states = possible_states(state)
        index = random.randint(0, len(new_states) - 1)
        state = new_states[index]
    return state

def h1(state):
    init_state = [[1, 2, 3], [4, 5, 6], [7, 8, -1]]
    count = 0

    for y in range(3):
        for x in range(3):
            if init_state[y][x] != state[y][x]:
                count += 1

    return count

def h1_helper(list):
    last_state_of_path = list[len(list)-1]
    return h1(last_state_of_path)



def searchStats(state):
    '''
    This is A* search algprithm which is given in the book chapter 5

    :param state: this is the initial state which is the initial state of the puzzle generated by generateState
    :return: the states that has seen while finding the result state
    '''
    queue = []
    path = []
    path.append(state)
    queue.append(path)
    while True:
        if len(queue) != 0:
            print ("A* search algorithm is starting...")
            print("Start of loop.")

            print("Paths in queue:")
            for p in queue:
                print(p)
            pth = queue.pop(0)

            print("Path to extend:")
            print(pth)

            last_state = pth[len(pth) - 1]
            nxt_states = possible_states(last_state)
            new_paths = []

            print("Possible next states:")
            for st in nxt_states:
                print(st)

            for st in nxt_states:

                if st == [[1, 2, 3], [4, 5, 6], [7, 8, -1]]:
                    print("The solution is found.")
                    new_path = pth
                    new_path.append(st)

                    for i in new_path:
                        print_state(i)
                    return new_path
                print("Checking:")
                print(st)
                if st not in pth:
                    print("Does not contain loop, extending path.")
                    # Searches whether or not that state is occurred before.
                    # If not adding it to the new paths list.
                    new_path = copy.deepcopy(pth)
                    new_path.append(st)
                    print(new_path)
                    new_paths.append(new_path)
                else:
                    print("Extension includes loop, discarded.")
            print("New paths that are obtained by extending:")

            for pt in new_paths:
                last_state = pt[len(pt) - 1]
                not_found = True
                not_found2 = True
                for q in queue:
                    if  not_found :
                        for state in q:
                            if not_found2:
                                if last_state == state:
                                    if q.index(state) > len(pt):
                                        queue.remove(q)
                                    else:
                                        new_paths.remove(pt)
                                        not_found = False
                                        not_found2 = False


            for pt in new_paths:
                print(pt)
                queue.append(pt)

            sorted(queue, key=h1_helper)

            print("End of loop, press Enter to continue.")


        else:
            print("The solution could not found for the initial state.")
            return

print("------------")
s = generate_state()
print_state( s )
print(h1(s))
searchStats(s)

"""
First We are generating 30 different initial states of the puzzle 
After generating, it is displayed as textual representation 
"""
initial_states = []
for i in range (1,31):
    print("Inittial State: " + str(i))
    initial_states.append(generate_state())
    print_state(initial_states[i-1])

no_of_moves = []

'''
Number of moves added to an array which will be used to draw the plot
As it is stated in the homework description We did not use loop (avoided loops).
each solution_  will include the solution paths that has been achieved for each initial state
'''
solution_0 = searchStats(initial_states[0])
no_of_moves.append(len(solution_0))
solution_1 = searchStats(initial_states[1])
no_of_moves.append(len(solution_1))
solution_2 = searchStats(initial_states[2])
no_of_moves.append(len(solution_2))
solution_3 = searchStats(initial_states[3])
no_of_moves.append(len(solution_3))
solution_4 = searchStats(initial_states[4])
no_of_moves.append(len(solution_4))
solution_5 = searchStats(initial_states[5])
no_of_moves.append(len(solution_5))
solution_6 = searchStats(initial_states[6])
no_of_moves.append(len(solution_6))
solution_7 = searchStats(initial_states[7])
no_of_moves.append(len(solution_7))
solution_8 = searchStats(initial_states[8])
no_of_moves.append(len(solution_8))
solution_9 = searchStats(initial_states[9])
no_of_moves.append(len(solution_9))
solution_10 = searchStats(initial_states[10])
no_of_moves.append(len(solution_10))
solution_11= searchStats(initial_states[11])
no_of_moves.append(len(solution_11))
solution_12 = searchStats(initial_states[12])
no_of_moves.append(len(solution_12))
solution_13 = searchStats(initial_states[13])
no_of_moves.append(len(solution_13))
solution_14 = searchStats(initial_states[14])
no_of_moves.append(len(solution_14))
solution_15 = searchStats(initial_states[15])
no_of_moves.append(len(solution_15))
solution_16 = searchStats(initial_states[16])
no_of_moves.append(len(solution_16))
solution_17 = searchStats(initial_states[17])
no_of_moves.append(len(solution_17))
solution_18 = searchStats(initial_states[18])
no_of_moves.append(len(solution_18))
solution_19 = searchStats(initial_states[18])
no_of_moves.append(len(solution_19))
solution_20 = searchStats(initial_states[20])
no_of_moves.append(len(solution_20))
solution_21 = searchStats(initial_states[21])
no_of_moves.append(len(solution_21))
solution_22 = searchStats(initial_states[22])
no_of_moves.append(len(solution_22))
solution_23 = searchStats(initial_states[23])
no_of_moves.append(len(solution_23))
solution_24 = searchStats(initial_states[24])
no_of_moves.append(len(solution_24))
solution_25 = searchStats(initial_states[25])
no_of_moves.append(len(solution_25))
solution_26 = searchStats(initial_states[26])
no_of_moves.append(len(solution_26))
solution_27 = searchStats(initial_states[27])
no_of_moves.append(len(solution_27))
solution_28 = searchStats(initial_states[28])
no_of_moves.append(len(solution_28))
solution_29 = searchStats(initial_states[29])
no_of_moves.append(len(solution_29))

# Initialize the plot
fig = plt.figure(figsize=(10,10))
graph = fig.add_subplot(111)

x_axis = []
for i in range (1,31):
    x_axis.append(i)

# Plot the data
graph.bar( x_axis , no_of_moves)
graph.set_title('Graph')
graph.set_xlabel('Initial-state Numbers')
graph.set_ylabel('Tile Moves')
# Show the plot
plt.show()

master = Tk()
master.title("ArcticFoxes")
w = Canvas(master, width=5000, height=8000, bg="white")

offset_x = 15
offset_y = 15
size = 50
table_nu = 0
for table in solution_5:
    for i in range(3):
        for j in range(3):
            x = 300* table_nu + 50 * i + offset_x
            y = 50 * j + offset_y

            num = table[j][i]
            w.create_rectangle(x, y, x + size, y + size, outline="black", width=1)
            w.create_text(x + 25, y + 25, font="Times 40 bold", text=str(num) , fill="blue")
    table_nu = table_nu + 1

table_nu = 0
for table in solution_27:
    for i in range(3):
        for j in range(3):
            x = 300* table_nu + 50 * i + offset_x
            y = 500 + 50 * j + offset_y

            num = table[j][i]
            w.create_rectangle(x, y, x + size, y + size, outline="black", width=1)
            w.create_text(x + 25, y + 25, font="Times 40 bold", text=str(num) , fill="blue")
    table_nu = table_nu + 1

w.pack()
master.mainloop()
